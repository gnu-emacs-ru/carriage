#+title: Концепция серверов — диалектический разбор и решение
#+author: Carriage Team (automated note)
#+language: ru
#+options: toc:2 num:t
#+property: header-args :results silent

* Введение
Здесь — диалектический разбор предложения перевести веб‑слой Carriage от модели «webd (отдельный Emacs‑демон)» к модели «рой агентов (headless Emacs‑процессы) + hub/реестр», а также практическое решение и план внедрения. В конце приведён блок #+begin_context с полным списком путей файлов (спеки, код, тесты), относящихся к задаче в этом репозитории.

* Исходный тезис (status quo)
Тезис: webd (отдельный Emacs) изолирует веб‑трафик и стримы от основной сессии. Плюсы — изоляция, предсказуемость, простая схема push/snapshot; минусы — сложность супервизора, runtime‑файлов, мостов и отладки.

* Антитезис (альтернативная идея)
Антитезис: поднять HTTP/SSE сервер прямо в основной сессии Emacs. Плюсы — простота эксплуатации, доступ к состоянию runtime прямо; минусы — риск фризов UI, необходимость жёсткой дисциплины (handlers отвечают из cache), увеличение площади безопасности и сложность обеспечения non‑blocking.

* Синтез (гармоничное решение)
Синтез: принять модель «рой агентов»:
- агент = headless Emacs с Carriage + локальным HTTP/SSE; отвечает только за свою сессию;
- hub = процесс, агрегирующий реестр агентов и проксирующий запросы браузера (браузер не видит токены);
- main Emacs остаётся оркестратором/панелью, не поднимает HTTP/SSE и не блокируется.

Ключевые принципы:
- handlers O(1) — отвечают из кэша; тяжёлая работа выполняется в idle‑таймерах или engine threads;
- loopback bind + отключённый CORS + необязательный X‑Auth token;
- минимальный whitelist команд; никакого arbitrary eval;
- per‑agent runtime dir (pid/port/token/meta) и общий registry (NDJSON) для discovery.

* Практическое решение — основной поток мыслей
1. Не автозапускать серверы в main Emacs (по умолчанию disabled). Явный старт — только под контролем пользователя.
2. Агент запускается как отдельный Emacs процесс (часто с -Q или минимальным init), регистрируется в registry и держит собственный HTTP/SSE.
3. Hub агрегирует registry, выполняет health‑probe асинхронно и проксирует браузерные запросы к агентам, подставляя X‑Auth.
4. Main Emacs имеет UI команды для старта/остановки агентов и открытия dashboard; все обращения — асинхронны, UI отвечает из кэша.
5. Обновление спецификаций и кода: ввести spec/swarm-v1 + agent/hub/registry спецификации; пометить webd‑спеки deprecated.

* Технические требования (кратко)
- bind = 127.0.0.1; default port = 8787 для hub, агенты по default port=0 (ephemeral);
- SSE baseline; reconnect tolerant; max clients limit;
- max json bytes, request size limits, truncation policy;
- registry: $XDG_RUNTIME_DIR/carriage-swarm/agents/<id>/{pid,port,token,meta.json} + registry.ndjson;
- handlers answer from cache; snapshot population via idle tasks or local publishers.

* Порядок внедрения (iterative patches)
1. Уточнить и добавить новые спецификации (swarm, agent API, hub API, registry).
2. Реализовать carriage-swarm-registry: атомарная запись, per-agent dirs, cleanup.
3. Переписать carriage-web.el в роль agent server (cache‑oriented).
4. Добавить carriage-agent.el — entrypoint агента (port=0, token, runtime dir, register).
5. Добавить carriage-hub.el — proxy + dashboard (hub injects X‑Auth).
6. Реализовать carriage-swarm-supervisor.el (start/stop/restart agents & hub).
7. Обновить main Emacs UI (carriage-global-mode.el, carriage-mode.el, keyspec) — асинхронные команды.
8. Убрать/редактировать старые push‑механизмы и webd‑артефакты.
9. Написать интеграционные тесты для registry/agent/hub.
10. Финальная гармонизация (именования, логирование, docs).

* Безопасность и совместимость
- По‑умолчанию browser не видит токены; hub проксирует запросы.
- Никогда не допускать arbitrary eval; команды строго по whitelist.
- TRAMP/remote apply запрещён; binary patches запрещены.
- При смене модели — пометить старые спеки как deprecated и предоставить migration notes (не обязательна обратная совместимость, если это требование пользователя).

* Критика предложенного пути (чтобы не повторять ошибок)
- Избегать «панели, которая может всё» — оставлять только проверённые whitelist команды; debug‑eval — отдельный opt‑in режим.
- Hub внутри main Emacs = риск. Рекомендация: hub как отдельный процесс или агент‑variant.
- Восстановление контекста (resume) требует сохранения state (carriage-doc-state / WIP branches) — без этого «перезапуск с того же места» невозможен.

* Полезные сценарии эксплуатации
- Запуск агента для проекта: supervisor создаёт runtime dir, запускает Emacs headless, агент регистрируется, hub видит запись и проксирует dashboard.
- Перезапуск агента: supervisor перезапускает процесс; если state сохранён (carriage-doc-state), агент восстанавливает контекст.
- Health/Cleanup: hub или отдельный cleanup job периодически помечает stale записи и удаляет dirs.

* Контекст: все релевантные файлы (спеки, код, тесты)
#+begin_context
spec/swarm-v1.org
spec/agent-http-api-v1.org
spec/hub-http-api-v1.org
spec/registry-v1.org
spec/web-dashboard-v1.org
spec/webd-ops-v1.org
spec/security-v2.org
spec/logging-v2.org
spec/ui-v2.org
lisp/carriage-web.el
lisp/carriage-agent.el            
lisp/carriage-hub.el              
lisp/carriage-swarm-registry.el   
lisp/carriage-swarm-supervisor.el 


lisp/carriage-global-mode.el
lisp/carriage-mode.el
lisp/carriage-logging.el
lisp/carriage-utils.el
lisp/carriage-apply.el
lisp/carriage-report.el
lisp/carriage-doc-state.el
lisp/carriage-ui.el
lisp/ops/carriage-op-sre.el
lisp/ops/carriage-op-patch.el
lisp/ops/carriage-op-file.el
lisp/ops/carriage-op-aibo.el
lisp/transports/carriage-transport.el
lisp/transports/carriage-transport-gptel.el
lisp/transports/carriage-transport-echo.el
test/carriage-swarm-registry-tests.el     
test/carriage-agent-server-tests.el      
test/carriage-hub-proxy-tests.el         
test/carriage-doc-state-idempotent-tests.el
test/carriage-doc-state-save-tests.el
test/carriage-doc-state-tests.el
doc/concepts/servers-concept.org
doc/concepts/servers-dialectic.org     
#+end_context

* Заключение
Предложенная архитектура «рой агентов + hub + registry» сохраняет изоляцию потоков и отказоустойчивость, при этом даёт простой и безопасный путь для управления Carriage‑сессиями. Переход реализуется итеративно: сперва спецификации и реестр, затем агентный сервер, hub, супервизор и UI‑интеграция. Главное правило — handlers не выполняют тяжёлой работы в обработчиках запросов и всё управление идёт через контролируемые, асинхронные, whitelist‑команды.

