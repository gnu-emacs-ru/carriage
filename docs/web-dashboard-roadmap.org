#+title: Carriage Web Dashboard — Roadmap and Iteration Guide
#+author: Carriage Team
#+language: en
#+options: toc:t num:t
#+property: header-args :results silent

Purpose
- Track near-term iterations to deliver a live dashboard over HTTP/SSE with safe command control.
- Keep changes inside Emacs Lisp first; consider Guix/Guile proxy after MVP.

State summary (now)
- Networking: HTTP server + SSE stream stable; graceful close fixed; headers and Content-Length accurate.
- Endpoints: /, /api/health, /api/sessions, /api/session/<id>, /api/report/last, /api/cmd (whitelist under flag), /api/metrics, /stream.
- Security: loopback binding; optional X-Auth; SSE accepts header or ?token=.
- Tests: ERT unit/integration + scripts/smoke-web.sh; real TCP checks; curl smoke target in Makefile.

Iteration A — sessions/cards/events (P1)
- Goal: Sessions list and a per-session card update live via SSE; favicon=204; logs readable.
- Tasks:
  - Validate /api/sessions and /api/session/<id> fields in real projects.
  - Include last report summary from cache; return sources when available.
  - Keep snapshot computation on-demand; introduce small cache keyed by buffer tick if needed.
  - Ensure favicon returns 204 No Content to reduce noise.
- Acceptance:
  - Browser shows sessions with phase/ctx/patch counters; details refresh via SSE without manual refresh.

Iteration B — command whitelist (P1)
- Goal: Buttons in UI trigger safe Carriage actions when enabled by flag.
- Tasks:
  - Enable carriage-web-api-commands-enabled and wire POST /api/cmd to:
    - apply_last_iteration, abort, report_open, commit_{last|all}, wip, toggle {ctx|files|visible|patched|profile}.
  - Resolve doc → buffer; execute in buffer context via run-at-time 0.
  - Return structured envelopes: ok/404/WEB_E_CMD/WEB_E_AUTH.
- Acceptance:
  - When flag is off → 400 WEB_E_CMD; when on → success or structured errors; SSE reflects state.

Iteration C — reports/limits/metrics (P2)
- Goal: Avoid heavy payloads in events; on-demand details via GET; add observability.
- Tasks:
  - /api/report/last?doc=<id>&limit=N: limit items and keep total/summary; cap JSON by carriage-web-max-json-bytes.
  - /api/metrics: counters (clients, published, truncated, ts).
  - Optional: small metrics panel in UI.
- Acceptance:
  - Streaming remains lightweight; metrics reveal activity; details fetched only when requested.

Iteration D — UX and stability polish
- SSE filtering: Use ?doc=<id> in EventSource when a single document is selected to reduce noise.
- UI: Token persistence via localStorage (already), error toasts, selective DOM updates.
- Performance: Cache ctx/patch counts by buffer tick; short TTL to avoid recomputation in large buffers.
- Docs: Extend Debugging and Testing Guide with practical scenarios.

Security and limits
- Keep loopback binding by default; require X-Auth for APIs when set; SSE accepts header or ?token=.
- No eval; strict command whitelist; log auth denials without leaking tokens.
- Enforce payload truncation (carriage-web-max-json-bytes); prefer summaries over large bodies.

Testing
- ERT:
  - Unit: parsing, dispatch, JSON truncation, sessions, session/<id>, report/last (ok/404/limit), cmd (ok/WEB_E_CMD/WEB_E_AUTH), metrics, SSE handshake.
  - Integration (real TCP): /, /api/health (+ X-Auth), /stream hello/heartbeat, no RST on normal paths.
- Smoke:
  - scripts/smoke-web.sh: /, /api/health, /api/metrics, /stream headers; accepts CARRIAGE_WEB_TOKEN.

Post‑MVP (optional)
- WebSocket channel for richer bidirectional control.
- Guix/Guile proxy (Unix domain socket JSON‑RPC) for heavy SPA/graphing; keep Emacs as state source.
- Pagination for /api/sessions; Last-Event-ID and event catch-up ring.

How to work
- Prefer small, incremental patches with ERT coverage per iteration.
- Keep SSE payloads compact; publish only summaries; details fetch via dedicated GET endpoints.
- Keep observable counters and minimal logs for fast triage.

