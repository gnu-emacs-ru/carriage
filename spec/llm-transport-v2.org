* LLM Transport (v2) — GPTel adapter

This document defines the contract for Carriage transports and the
reference GPTel transport implementation.

** Goals
- Small, predictable transport (minimal state).
- Streaming output via callbacks (no "magic" keepalive in hot path).
- Self-healing on hangs/errors without requiring Emacs restart:
  - watchdog timeout → abort → cleanup.
- Diagnostics on every finalization:
  - what callback delivered (RESPONSE/INFO shape),
  - final result (DONE/ABORT/ERROR/TIMEOUT),
  - live gptel-curl processes before/after cleanup,
  - actions taken (abort/cleanup/watchdog).

** Non-goals
- No usage parsing via SSE trailers.
- No advices into gptel internals.
- No keepalive/accept-process-output loops in hot path.
- Pricing is best-effort; missing usage must be explicit in logs.

** Transport event contract

Carriage transports MUST drive the UI via:
- `carriage-transport-begin`
- `carriage-transport-streaming` (first streamed content)
- `carriage-transport-complete` (finalize; errorp indicates failure)

** GPTel callback semantics (assumed)

The GPTel callback is called with (RESPONSE INFO):
- RESPONSE is a string: streamed text chunk
- RESPONSE is t: successful completion
- RESPONSE is nil: failure (inspect INFO for status/error)
- RESPONSE is symbol `abort`: aborted request
- RESPONSE is (reasoning . TEXT|t): reasoning chunk or end marker
- RESPONSE may be other cons values (tool-call / tool-result). Transport must not crash.

** GPTel transport v2 design

*** Minimal per-request state
- request-id (string)
- start-ts, last-activity-ts
- finished flag
- first-streamed flag
- last-response-snippet (string, clipped)
- last-info-snippet (string, clipped)
- last-info-keys (list of keys, clipped)

*** Watchdog (mandatory)
- A per-request watchdog timer MUST be started on dispatch.
- Default timeout is 30 seconds (configurable).
- Watchdog MUST be **two-phase**:
  - **startup timeout**: applies until the first streamed content chunk arrives (string response or (reasoning . string)).
  - **silence timeout**: applies after first streamed content arrives, and MAY be larger than startup timeout.
    If the implementation provides only a single user option, it MUST interpret it as startup timeout and MAY
    internally extend the silence timeout to a safe floor (e.g., 60s) to avoid aborting valid long generations.
- Watchdog fires when (now - last-activity) > current-timeout:
  - logs TIMEOUT with phase (startup|silence) and process inventory,
  - calls `gptel-abort` for origin buffer (best-effort),
  - runs cleanup policy (see below),
  - MUST finalize the transport even if GPTel never delivers a terminal callback
    (code LLM_E_TIMEOUT).
- Late callbacks: after transport finalization, any subsequent GPTel callback invocations MUST be ignored safely
  (no non-local exits, no thrown errors, no state changes), but MAY be logged as "LATE" under diagnostics.

*** Cleanup policy (mandatory)
Default policy: aggressive-on-error.
- On DONE: no cleanup (avoid side effects).
- On ERROR/ABORT/TIMEOUT:
  - call `gptel-abort` (best-effort),
  - snapshot live `gptel-curl` processes (name match),
  - after a short delay (0.2s) kill remaining live `gptel-curl*` processes
    (delete-process), even if they are still listed in `gptel--request-alist`,
  - log before/after inventories and count killed.

NOTE: This may kill unrelated GPTel requests. This is allowed by policy
"reliability over isolation", but MUST be explicitly logged as "global cleanup".

*** Diagnostics (mandatory)
On every finalize (DONE/ABORT/ERROR/TIMEOUT) transport MUST log a single
summary line in *carriage-log* containing:
- request-id
- final kind
- classification code (see below)
- INFO :status, :http-status (if present)
- response kind (string/t/nil/symbol/cons)
- gptel--request-alist size (if bound)
- live gptel-curl processes count before cleanup and after cleanup
- actions taken: abort-called? watchdog-fired? killed=N?

On failure (ERROR/ABORT/TIMEOUT) additionally log:
- last-response-snippet
- last-info-keys + last-info-snippet (clipped)

If callback processing itself errors, it MUST be classified as LLM_E_INTERNAL
and log error + backtrace (best-effort) to *carriage-log*.

*** Error classification codes
Minimal set for gptel transport v2:
- LLM_E_TIMEOUT
- LLM_E_ABORT
- LLM_E_PROVIDER     (INFO has :error or non-2xx HTTP)
- LLM_E_NETWORK      (no INFO error but nil response; transport-level failure)
- LLM_E_INTERNAL     (callback handler crashed)
- LLM_E_UNKNOWN      (fallback)

HTTP-based refinement is allowed:
- 401/403 → LLM_E_AUTH
- 429 → LLM_E_RATE_LIMIT
…but is optional.

** Implementation requirements
- Must be contained in a single file `lisp/carriage-transport-gptel.el`.
- Must provide entry-point: `carriage-transport-gptel-v2-dispatch`.
- Must not install advices into gptel or rely on gptel internal stream parsing.
- Must not run keepalive loops; only watchdog is allowed.
- Must never signal unhandled errors from callback; all failures must finalize cleanly.
